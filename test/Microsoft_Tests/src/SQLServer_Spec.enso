from Standard.Base import all
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument
import Standard.Base.Errors.Illegal_State.Illegal_State
import Standard.Base.Runtime.Ref.Ref

from Standard.Table import Table, Value_Type, Aggregate_Column, Bits, expr
from Standard.Table.Errors import Invalid_Column_Names, Inexact_Type_Coercion, Duplicate_Output_Column_Names

import Standard.Database.DB_Column.DB_Column
import Standard.Database.DB_Table.DB_Table
import Standard.Database.SQL_Type.SQL_Type
import Standard.Database.Internal.Replace_Params.Replace_Params
from Standard.Database import all
from Standard.Database.Errors import all

from Standard.Microsoft import all

from Standard.Test import all
import Standard.Test.Test_Environment

import enso_dev.Table_Tests
import enso_dev.Table_Tests.Database.Common.Common_Spec
import enso_dev.Table_Tests.Database.Transaction_Spec
import enso_dev.Table_Tests.Database.Upload_Spec
import enso_dev.Table_Tests.Database.Helpers.Name_Generator
import enso_dev.Table_Tests.Common_Table_Operations
from enso_dev.Table_Tests.Common_Table_Operations.Util import all
from enso_dev.Table_Tests.Database.Types.Postgres_Type_Mapping_Spec import default_text
from enso_dev.Table_Tests.Database.Postgres_Spec import Basic_Test_Data, Postgres_Tables_Data

import enso_dev.Base_Tests.Network.Enso_Cloud.Cloud_Tests_Setup.Cloud_Tests_Setup

type SQLServer_Info_Data
    Value ~data

    connection self = self.data.at 0
    tinfo self = self.data.at 1
    t self = self.data.at 2

    setup create_connection_fn = SQLServer_Info_Data.Value <|
        connection = create_connection_fn Nothing
        tinfo = Name_Generator.random_name "Tinfo"
        connection.execute_update 'CREATE TEMPORARY TABLE "'+tinfo+'" ("strs" VARCHAR, "ints" NUMBER(38,0), "bools" BOOLEAN, "doubles" FLOAT8)'
        t = connection.query (SQL_Query.Table_Name tinfo)
        row1 = ["a", Nothing, False, 1.2]
        row2 = ["abc", Nothing, Nothing, 1.3]
        row3 = ["def", 42, True, 1.4]
        Panic.rethrow <|
            t.update_rows (Table.from_rows ["strs", "ints", "bools", "doubles"] [row1, row2, row3]) update_action=Update_Action.Insert
        [connection, tinfo, t]

    teardown self =
        self.connection.execute_update 'DROP TABLE "'+self.tinfo+'"'
        self.connection.close

get_configured_connection_details =
    host = Environment.get "ENSO_SQLSERVER_HOST" if_missing="localhost"
    port = Environment.get "ENSO_SQLSERVER_PORT" if_missing="1433"
    user = Environment.get "ENSO_SQLSERVER_USER" if_missing="sa"
    password = Environment.get "ENSO_SQLSERVER_PASSWORD" if_missing="<YourStrong@Passw0rd>"
    database = Environment.get "ENSO_SQLSERVER_DATABASE" if_missing="master"
    resolved_password = if password.starts_with "enso://" then Enso_Secret.get password else password
    credentials = Credentials.Username_And_Password user resolved_password
    SQLServer_Details.SQLServer host port credentials database

## Returns a function that takes anything and returns a new connection.
   The function creates a _new_ connection on each invocation
   (this is needed for some tests that need multiple distinct connections).
create_connection_builder =
    connection_details = get_configured_connection_details
    connection_details.if_not_nothing <|
        _ -> Database.connect connection_details

add_specs suite_builder =
    suite_builder.group "[SQLServer] Info" group_builder->
        group_builder.specify "should return Table information" <|
            conn = Database.connect get_configured_connection_details
            conn.should_succeed
            new_database = conn.read (SQL_Query.Raw_SQL "SELECT '1' as c") . at 0 . to_vector . first
            new_database.should_equal "master"
            [1] . should_equal [3, 1, 2, 3]

main filter=Nothing =
    suite = Test.build suite_builder->
        add_specs suite_builder
    suite.run_with_filter filter
